a) BigDecimal’s, equals() and compareTo() methods are inconsistent. In the given code, the Hashset add()
method uses BigDecimal equals() and BigDecimal hashCode() to evaluate elements.
To formulate sensible answers to this problem, we have to make a decision about the
level of abstraction at which we define state. For the purpose of this exercise, we’ll
assume that we have access to the state represented by variables in the given code, but
do not have access to state internal to BigDecimal or the sets. By that, we should override one of them.

b) All tests that involve calls to equals() and/or hashCode() execute the fault. In terms
of the given code, this means calls to certain HashSet methods.

c) Input: 
  BigDecimal a = new BigDecimal(”5.0”);
  BigDecimal b = new BigDecimal(”5.0”);
  Set<BigDecimal>BDTree = new TreeSet <BigDecimal> ();
  BDTree.add(a);
  BDTree.add(b);
  Set<BigDecimal>BDHash = new HashSet <BigDecimal> ();
  BDHash.add(a);
  BDHash.add(b);
Expected Output: 
  System.out.println(BDTree); 
  System.out.println(BDHash); 

d) An error state in the given context means that a HashSet object contains an object it
should not, or does not contain an object it should. Hence, every error state results in
failure if we call an appropriate observer on the HashSet.

e) When the PC is just past s.add(y), s now contains two values, 1.0 and 1.00.

f) The only way to fix the fault is to change how equals() evaluates numbers for BigDecimal.
Since BigDecimal is a part of Java API, there is no way to do this without breaking
client code.
