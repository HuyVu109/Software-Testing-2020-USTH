
7.5.1
a, 
The four values for elements are [ null, null ], [ obj, null ], [ null, obj ] and [ obj, obj ]
[ obj, null ] and [ null, obj ] are different at the representation level

b, 
The number of states = Element * size * front * back = 4 * 3 * 2 * 2 = 48 total states.

c,
Of the 48 states, only 6 are reachable.

d + e,
The exceptions (enqueue() on full queues and dequeue() on empty queues) as well as observer method. Result in "loop transitions from a state back to itself.
These are not shown on the diagram for clarity and from a grading perspective, aren't relevant. Labels on nodes show the values of the representation state variables : Elements, size, front and back.

f,Small test :
Queue q = new Queue();
Object obj = new Object();
q.enqueue(obj);
q.enqueue(obj);
q.dequeue();
q.enqueue(obj);
q.dequeue();
q.dequeue();
q.enqueue(obj);
q.dequeue();

7.5.2
a,
There are 4 states:
(1) : (Wake, Low)
(2) : (Wake, High)
(3) : (Sleep, Low)
(4) : (Sleep, High)

b,
There are 12 edges (3 total methods each of which applies in 4 states). The initial states is (1)

1, advance(): (1) --> (3)
2, advance(): (2) --> (4)
3, advance(): (3) --> (1)
4, advance(): (4) --> (2)
5, up() : (1) --> (2)
6, up() : (2) --> (2)
7, up() : (3) --> (4)
8, up() : (4) --> (4)
9, down() : (1) --> (1)
10,down() : (2) --> (1)
11,down() : (3) --> (3)
12,down() : (4) --> (3)

c, 
Initially in state (1)
down() - edge 9 to state (1)
advance() - edge 1 to state (3)
down() - edge 11 to state (3)
up() -  edge 7 to state (4)
up() - edge 8 to state (4)
advance() - edge 4 to state (2)
up() - edge 6 to state (2)
down()- edge 10 to state (1)
up() - edge 5 to state (2)
advance() - edge 2 to state (4)
down() - edge 12 to state (3)
advance() - edge 3 to state (1)
